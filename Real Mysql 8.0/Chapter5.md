# chapter 5 트랜잭션과 잠금

트랜잭션과 잠금은 서로 비슷한 개념 같지만 명확한 차이가 있다.

- 잠금 : 동시성을 제어하기위한 기능
- 트랜잭션 : 데이터의 정합성을 보장하는 기능

회원 정보 레코드를 여러 커넥션에서 동시에 변경하려 하는데 잠금이 없다면 하나의 데이터를 여러 커넥션에서 동시에 변경할 수 있게된다.

## 5.1 트랜잭션
MyISAM이나 MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않지만 InnoDB는 트랜잭션을 지원한다.

### 5.1.1 MySQL에서의 트랜잭션 
트랜잭션은 하나의 논리적인 작업 셋(set)이 100% 적용되거나(commit) 아무것도 적용되지 않아야 한다(rollback). 그 작업 셋에 쿼리가 몇개가 있던 상관없다.

다음은 InnoDB와 MyISAM 테이블에서의 차이이다.

```sql 
create table tab_myisam(fdpk int not null, primary key(fdpk)) engine=MyISAM;

insert into tab_myisam (fdpk) values(3);

create table tab_innodb (fdpk int not null, primary key(fdpk)) engine=INNODB;
insert into tab_innodb(fdpk) values(3);
```

```sql
set autocommit = on;

insert into tab_myisam (fdpk) values (1), (2), (3);

insert into tab_innodb (fdpk) values (1), (2), (3);
```

결과는 myisam쪽은 1, 2, 3이 모두 들어가지만 innodb는 3만 들어가있는 상태가 된다.(innodb는 트랜잭션을 지원해 작업 전체가 롤백되기 때문이다.)

### 5.1.2 주의사항
트랜잭션은 DBMS 커넥션과 마찬가지로 꼭 필요한 코드에만 적용하는것이 좋다. 즉 프로그램에서 트랜잭션의 범위를 최소한으로 하라는 말이다. 

책에서 소개하는 예시이다.(사용자가 게시판에 게시물을 작성한 후 서버에서 처리하는 내용이다.)

1. 처리 시작
    - -> DB 커넥션 생성
    - -> 트랜잭션 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS에 저장
    - <- 트랜잭션 종료(commit)
    - <- DB 커넥션 반납
10. 처리완료

커넥션과 트랜잭션의 범위는 최대한 작게 갖고가는것이 좋다. 


- 커넥션 : db커넥션은 갯수가 제한적이라 커넥션을 소유하고 있는 시간이 길어지면 길어질수록 여유 커넥션 갯수가 줄어들 것이다. 위 예시로 봤을때 2, 3, 4번 과정이 아무리 빨라도 불필요한 시간이기 때문에 최악의 경우엔 커넥션이 부족할 수 있다.
- 트랜잭션 : 이 처리절차에는 DBMS작업이 총 4가지가 있는데 사용자가 입력한 정보를 저장하는 5, 6번은 하나의 트랜잭션으로 묶어야하며, 7번의경우 단순조회이기 때문에 트랜잭션에 포함시키지 않아도 되고 9번의 경우 5, 6번과의 성격이 조금 다르기 때문에 별도의 트랜잭션에 포함시켜야한다.

개선하면 다음과 같다.
1. 처리시작
2. 로그인 여부 확인
3. 글쓰기 내용의 오류 발생 여부 확인
4. 업로드된 파일 확인 및 저장
    - -> 커넥션 생성
    - -> 트랜잭션 시작
5. 입력내용 dbms저장
6. 첨부파일 정보 dbms저장
    - <- commit
7. 저장된 내용 또는 기타 정보를 dbms에서 조회
8. 알림 메일 전송
    - -> tx 시작
9. 알림 메일 발송 이력을 dbms에 저장
    - <- commit
    - <- 커넥션 반납
10. 처리 완료

트랜잭션의 범위는 구현하고자하는 업무의 특성에 따라 범위가 달라질 수 있다. 요점은 프로그램의 코드가 DB커넥션을 갖고있는 범위와 트랜잭션이 활성화 되있는 프로그램의 범위를 최소한으로 해야한다는 것이다. 

추가로 프로그램의 코드는 한 두줄이라도 네트워크 작업이 있는 경우엔 반드시 트랜잭션에서 배제해야 한다.


## 5.2 MySQL 엔진 잠금
MySQL에서의 잠금은 크게 스토리지 엔진 레벨과, MySQL 엔진 레벨이 있다. MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지간 상호 영향을 미치지 않는다.

### 5.2.1 글로벌 락
글로벌락은 MySQL이 제공하는 잠금 가운데 가장 범위가 크다. 한 세션에서 글로벌 락을 획득하면 다른 세션에서 select를 제외한 ddl, dml문장을 실행하면 글로벌 락이 해제될 때까지 해당 문장이 대기상태로 남는다. 

글로벌 락이 미치는 범위는 MySQL범위 전체이며, 작업 대상 테이블이나 DB가 달라도 동일하게 영향을 미친다.(FLUSH TABLES WITH READ LOCK 명령으로 획득할 수 있다.)

트랜잭션을 지원하지않는 MyISAM에이나 memory테이블에 대해 mysqldump로 일관된 백업을 받아야할 때 글로벌 락을 사용한다.

innodb의 경우 트랜잭션을 지원하기 때문에 myisam, memory 테이블처럼 백업을 위해 글로벌락을 획득할 필요가 없다. mysql 8.0부턴 innodb가 기본 엔진으로 채택됐기 때문에 조금 더 가벼운 글로벌락인 백업 락이 도입됐다. 백업락을 획득했을때 모든 세션에서 다음과 같은 정보 변경을 할 수 없다.

1. DB및 테이블 등 모드느 객체 생성 및 변경, 삭제
2. repair table과 optimize table 명령
3. 사용자 관리 및 비밀번호 변경

하지만 일반적인 테이블의 데이터 변경은 허용된다.

### 5.2.2 테이블락
이름에서 알수 있듯이 테이블락은 테이블단위로 설정하는 잠금이다. 
테이블락은 두종류 명시적 잠금과 묵시적 잠금이 존재한다.
- 명시적 잠금 : LOCK TABLES table_name [READ | WRITE] 명령으로 특정 테이블 락을 획득할 수 있다.(myisam, innodb 상관없이 동일하다.) 명시적으로 획득한 잠금은 UNLOCK TABLES 명령으로 잠금을 반납할 수 있다. 
- 묵시적 잠금 : 묵시적 잠금의경우 트랜잭션으르 지원하는 innodb와 트랜잭션을 지원하지 않은 myisam, memory에서 차이를 보인다.
    - myisam, memory : 테이블의 데이터를 변경하는 쿼리가 실행되면 자동으로 잠금이 발생하고 데이터가 변경되는 즉시 잠금이 해제된다. 
    - innodb : 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경으로는 묵시적 테이블락이 걸리지 않는다. 대신 스키마를 변경하는 쿼리(ddl)의 경우에만 묵시적 테이블락이 걸린다. 

### 5.2.3 네임드 락
