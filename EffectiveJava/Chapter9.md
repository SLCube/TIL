# 일반적인 프로그래밍 원칙

## item57 지역변수의 범위를 최소화하라
c언어와 같이 역사가 깊은 언어들에서 지역변수를 선언할 때 코드블록의 첫머리에 선언하는 경우가 많고, 지금도 이 방식을 습관처럼 따르는 프로그래머들이 많다. 

지역변수의 범위를 줄이는 가장 강력한 방법은 가장 처음 쓰일때 선언하는 것이다. 추가로 거의 모든 지역변수를 선언과 동시에 초기화를 해야한다.

이렇게 간단한 원칙이지만 반복문에선 조금 독특한 방식으로 변수 범위를 최소화해준다.

프로그래밍 공부를 처음할때 while문과 for문의 본질적인 차이를 이해하지 못했다. 

```java
int i = 0;
while(i < 10) {
    // 어쩌구 저쩌구
    i++;
}

int i2 = 0;
while(i < 10) {
    // 어쩌구 저쩌구
    i2++;
}
```

개발자의 실수로 두번째 while문에서 반복변수를 i2가 아닌 i를 사용했고 두번째 반복문은 실행이 되지 않는다. 이는 컴파일도 잘되고 실행시 예외를 터뜨리지 않는다. 두번째 반복문이 정말 드물게 실행되는 코드라면 해당 오류는 오랜시간 뒤에 발견될 수 있다. 

```java
for(i = 0; i < 10; i++) {
    // 어쩌구 저쩌구
}

for(i = 0; i < 10; i++) {
    // 어쩌구 저쩌구
}
```

for문을 사용하게되면 반복변수 i가 반복문이 실행될때 초기화되고 반복문이 끝날때 소멸된다. 

지역변수의 범위를 최소화하는 마지막 방법은 메소드를 작게 유지하는 것이다. 한 메소드가 여러기능을 한다면 그중 한 기능과 관련된 지역변수라도 다른 기능에서 접근이 가능하다. 기능단위로 메소드를 쪼개면 지역변수와 관련된 오류를 잡는데 큰 도움이 될것이다.

## item58 전통적인 for문보다 for-each문을 사용하라

다음은 전통적인 for문을 이용해 컬렉션과 배열을 순회하는 코드이다. 

```java
for(i = 0; i < list.size(); i++) {
    //...
}

for(i = 0; i < arr.length; i++) {
    //arr[i]...
}
```

while문보다는 확실히 좋지만 문제가 몇몇 보인다. 반복변수는 해당 기능에 필요가 없는 경우가 많다. 우리가 정말로 필요한건 컬렉션과 배열안에 있는 원소일뿐 그들의 인덱스번호가 아니기 때문이다. 컬렉션 반복문에선 i가 3번 배열 반복문에선 4번 등장한다. 향상된 for문으로 고쳐보자

```java
for(Element e : elements) {
    // ...
}
```

for each문을 사용할 수 없는 상황은 세가지가 있다. 
1. 컬렉션을 순회하면서 해당 원소를 제거해야한다면 해당 컬렉션의 인덱스가 필요하다.
2. 리스트나 배열을 순회하면서 원소의 값을 변경하려면 인덱스가 필요하다. 
3. 여러 컬렉션을 병렬로 순회해야한다면 각각의 반복자와 인덱스 변수를 엄격하게 관리하면서 사용해야한다. 

## item59 라이브러리를 익히고 사용하라.
이번 아이템에서 예시로 설명한 코드들이 있지만 코드를 설명하기보단 새로 구현하지 않고 라이브러리를 익혀서 사용해야하는 이유에 대해 정리하려 한다.

필자가 입버릇처럼 하는 말인데 '내가 필요하면 누군가도 필요할거고 그러면 이 세상에 누군가는 만들었다.' 라고 자주 말한다. 그 기능이 추상화가 가능한 기능이라면 분명 라이브러리로 만들어져 있을 것이다. 라이브러리는 개인이 만든 코드가 아니라 수많은 개발자가 참여하게 된다. 그만큼 많은 사람들의 관심을 받게되고 자연스럽게 코드의 품질이 올라가게 될것이다. 

자바 표준라이브러리에서 제공하지 않는 기능을 원한다면 고품질의 서드파티 라이브러리를 찾아보자. 적합한 라이브러리를 못찾았다면 직접 구현할 수 밖에 없다.

다시 한번 명심하자. 바퀴를 다시 발명하지 말자.

## item60 정확한 답이 필요하다면 float와 double은 피하라

float와 double은 부동소수점 연산에 쓰인다. 과학, 공학 계산용으로 설계되어 넓은 범위의 수를 빠르고 꽤 정밀한 '근사치'로 계산되게 설계되었다. 문제는 근사치라는 것이다. 정확한 계산결과를 원한다면, 특히 금융관련 계산과는 맞지 않다는 것이다. 

예를들어 지갑에 1.03달러가 있는데 그중 42센트를 썼다고 해보자.

```java
System.out.println(1.03 - 0.42);
```

우리는 0.61을 기대하겠지만 위 코드는 0.6100000000000001을 출력한다. 

다른 예를들어 지갑에 1달러가 있는데 10센트짜리 사탕 9개를 샀다고 해보자

```java
System.out.println(1 - 0.10 * 9);
```

우리의 예상과는 다르게 0.09999999999999998가 출력된다. 반올림을 통해 해결할 수 있겠다 생각하겠지만 근본적인 해결책은 아니다.

금융계산에는 BigDecimal, int 혹은 long을 사용해야 한다. 

BigDecimal의 단점은 기존 타입보다 사용하기 불편하고, 느리다는 단점이 있다. 느리다는 문제는 상황에 따라 무시할 수 있지만 사용하기 불편하다는건 해결하고 싶을것이다. 

대안으로 int나 long타입을 사용할 수 있다. 이럴경우엔 소수점을 직접 관리해줘야한다.