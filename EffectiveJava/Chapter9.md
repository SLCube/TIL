# 일반적인 프로그래밍 원칙

## item57 지역변수의 범위를 최소화하라
c언어와 같이 역사가 깊은 언어들에서 지역변수를 선언할 때 코드블록의 첫머리에 선언하는 경우가 많고, 지금도 이 방식을 습관처럼 따르는 프로그래머들이 많다. 

지역변수의 범위를 줄이는 가장 강력한 방법은 가장 처음 쓰일때 선언하는 것이다. 추가로 거의 모든 지역변수를 선언과 동시에 초기화를 해야한다.

이렇게 간단한 원칙이지만 반복문에선 조금 독특한 방식으로 변수 범위를 최소화해준다.

프로그래밍 공부를 처음할때 while문과 for문의 본질적인 차이를 이해하지 못했다. 

```java
int i = 0;
while(i < 10) {
    // 어쩌구 저쩌구
    i++;
}

int i2 = 0;
while(i < 10) {
    // 어쩌구 저쩌구
    i2++;
}
```

개발자의 실수로 두번째 while문에서 반복변수를 i2가 아닌 i를 사용했고 두번째 반복문은 실행이 되지 않는다. 이는 컴파일도 잘되고 실행시 예외를 터뜨리지 않는다. 두번째 반복문이 정말 드물게 실행되는 코드라면 해당 오류는 오랜시간 뒤에 발견될 수 있다. 

```java
for(i = 0; i < 10; i++) {
    // 어쩌구 저쩌구
}

for(i = 0; i < 10; i++) {
    // 어쩌구 저쩌구
}
```

for문을 사용하게되면 반복변수 i가 반복문이 실행될때 초기화되고 반복문이 끝날때 소멸된다. 

지역변수의 범위를 최소화하는 마지막 방법은 메소드를 작게 유지하는 것이다. 한 메소드가 여러기능을 한다면 그중 한 기능과 관련된 지역변수라도 다른 기능에서 접근이 가능하다. 기능단위로 메소드를 쪼개면 지역변수와 관련된 오류를 잡는데 큰 도움이 될것이다.

## item58 전통적인 for문보다 for-each문을 사용하라

다음은 전통적인 for문을 이용해 컬렉션과 배열을 순회하는 코드이다. 

```java
for(i = 0; i < list.size(); i++) {
    //...
}

for(i = 0; i < arr.length; i++) {
    //arr[i]...
}
```

while문보다는 확실히 좋지만 문제가 몇몇 보인다. 반복변수는 해당 기능에 필요가 없는 경우가 많다. 우리가 정말로 필요한건 컬렉션과 배열안에 있는 원소일뿐 그들의 인덱스번호가 아니기 때문이다. 컬렉션 반복문에선 i가 3번 배열 반복문에선 4번 등장한다. 향상된 for문으로 고쳐보자

```java
for(Element e : elements) {
    // ...
}
```

for each문을 사용할 수 없는 상황은 세가지가 있다. 
1. 컬렉션을 순회하면서 해당 원소를 제거해야한다면 해당 컬렉션의 인덱스가 필요하다.
2. 리스트나 배열을 순회하면서 원소의 값을 변경하려면 인덱스가 필요하다. 
3. 여러 컬렉션을 병렬로 순회해야한다면 각각의 반복자와 인덱스 변수를 엄격하게 관리하면서 사용해야한다. 

## item59 라이브러리를 익히고 사용하라.
이번 아이템에서 예시로 설명한 코드들이 있지만 코드를 설명하기보단 새로 구현하지 않고 라이브러리를 익혀서 사용해야하는 이유에 대해 정리하려 한다.

필자가 입버릇처럼 하는 말인데 '내가 필요하면 누군가도 필요할거고 그러면 이 세상에 누군가는 만들었다.' 라고 자주 말한다. 그 기능이 추상화가 가능한 기능이라면 분명 라이브러리로 만들어져 있을 것이다. 라이브러리는 개인이 만든 코드가 아니라 수많은 개발자가 참여하게 된다. 그만큼 많은 사람들의 관심을 받게되고 자연스럽게 코드의 품질이 올라가게 될것이다. 

자바 표준라이브러리에서 제공하지 않는 기능을 원한다면 고품질의 서드파티 라이브러리를 찾아보자. 적합한 라이브러리를 못찾았다면 직접 구현할 수 밖에 없다.

다시 한번 명심하자. 바퀴를 다시 발명하지 말자.

## item60 정확한 답이 필요하다면 float와 double은 피하라

float와 double은 부동소수점 연산에 쓰인다. 과학, 공학 계산용으로 설계되어 넓은 범위의 수를 빠르고 꽤 정밀한 '근사치'로 계산되게 설계되었다. 문제는 근사치라는 것이다. 정확한 계산결과를 원한다면, 특히 금융관련 계산과는 맞지 않다는 것이다. 

예를들어 지갑에 1.03달러가 있는데 그중 42센트를 썼다고 해보자.

```java
System.out.println(1.03 - 0.42);
```

우리는 0.61을 기대하겠지만 위 코드는 0.6100000000000001을 출력한다. 

다른 예를들어 지갑에 1달러가 있는데 10센트짜리 사탕 9개를 샀다고 해보자

```java
System.out.println(1 - 0.10 * 9);
```

우리의 예상과는 다르게 0.09999999999999998가 출력된다. 반올림을 통해 해결할 수 있겠다 생각하겠지만 근본적인 해결책은 아니다.

금융계산에는 BigDecimal, int 혹은 long을 사용해야 한다. 

BigDecimal의 단점은 기존 타입보다 사용하기 불편하고, 느리다는 단점이 있다. 느리다는 문제는 상황에 따라 무시할 수 있지만 사용하기 불편하다는건 해결하고 싶을것이다. 

대안으로 int나 long타입을 사용할 수 있다. 이럴경우엔 소수점을 직접 관리해줘야한다.

## item61 박싱된 기본타입보다는 기본타입을 사용하라.

자바의 데이터타입은 크게 기본타입과 참조타입을 가질 수 있다. 그리고 그 기본타입에 대응하는 참조타입이 있으며 이를 박싱된 기본타입이라 부른다.

자바에는 오토박싱, 오토언박싱 덕분에 두 종류의 타입을 큰 구분없이 사용할 수 있지만 차이가 사라지는건 아니다. 

기본타입과 박싱된 타입의 차이점은 크게 3가지가 있다. 
1. 기본타입은 값만 갖고있지만, 박싱된 타입은 식별성(identity)을 추가로 갖는다. 박싱된 타입은 서로 값이 같아도 다르다고 식별될 수 있다. 
2. 기본타입은 항상 유효한 값을 갖고있지만, 박싱된 타입은 null을 가질 수 있다.
3. 기본타입이 시간과 메모리측면에서 더 효율적이다. 

첫번째 차이를 알아보자
```java
public class Sample {
    public static void main(String[] args) {
        Comparator<Integer> naturalOrder =
                (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);

        System.out.println("naturalOrder.compare(new Integer()) = " + naturalOrder.compare(new Integer(42), new Integer(42)));
    }
}
```

0을 출력할 것 같지만 1을 출력한다. 첫번째 검사는 잘 작동하지만, 두번째 검사에서 == 비교를 하게 되는데 식별자가 다르기 때문에 서로 다른 Integer로 판단하고 1을 출력하게 되는것이다. 

두번째 차이점을 알아보자.

```java
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42) {
            System.out.println("Unbelievable");
        }
    }
}
```

Unbelievable을 출력하진 않지만 NullPointException을 던진다. 기본타입은 null로 초기화할 수 없지만 박싱된 타입은 null로 초기화가 가능하기 때문이다. i == 42구문에서 박싱된 타입과 기본타입을 비교하게 되는데 이런경우엔 박싱이 자동으로 풀리게 된다. 그 뒤에 null을 참조하기 때문에 NullPointException이 터지게 되는것이다. 

마지막 차이를 알아보자. item6에서 살펴본 코드이기도 하다.
```java
public class Sample {
    public static void main(String[] args) {
        Long sum = 0L;
        long start = System.currentTimeMillis();
        for (long i = 0; i < Integer.MAX_VALUE; i++) {
            sum += i;
        }
        long end = System.currentTimeMillis();
        System.out.println("sum = " + sum);
        System.out.println("end - start = " + (end - start) + "ms");
    }
}
```

지역변수 sum을 박싱된 기본타입으로 선언해 느려진 케이스이다. 추가로 수행시간을 체크해봤는데 필자의 노트북(apple m1 air ram16gb)기준 약2.7초가 걸렸다.(5회 테스트해봤다.) sum을 단순히 기본타입인 long타입으로 바꿔주기만해도 수행시간이 0.7초 약 4배가량 빨라지는 모습을 볼 수 있다. 

그렇다면 언제 써야할까?
1. 컬렉션의 원소 혹은 키값. 매개변수화 타입이나 매개변수화 메소드의 타입 매개변수는 기본타입으로 쓸 수 없기때문에 어쩔수 없다. 
2. 리플렉션을 통해 메소드를 호출할때도 박싱된 기본타입을 사용해야한다. 

## item62 다른 타입이 필요하면 문자열 사용은 피해라

문자열은 말그대로 정말 문자를 표현하기 위해서만 사용해야한다. 문자열은 다른 타입을 대체하기에 적합하지 않다. 일반타입이던 참조타입이던 적절한 타입을 찾고 찾지 못한다면 새로운 타입 하나를 정의해야한다. 몇가지 케이스를 살펴보자

1. 문자열은 열거타입을 대체하기에 적합하지 않다. 앞에 열거타입에서도 언급한 내용이지만 열거타입은 정말 enum타입으로 선언해야한다. 숫자나 문자로 표현하기에 적합하지 않다. 

2. 여러요소가 혼합된 데이터를 하나의 문자열로 처리하려하는 방법은 좋지 않다. 문자열로 처리하게되면 String이 제공해주는 기능만 이용할 수 밖에 없고, 혼합된 요소중 하나 혹은 몇개의 데이터만 원한다면 문자열을 파싱해야하는 불필요한 연산을 해야한다. 차라리 전용 클래스를 하나 만들자.

3. 문자열은 권한을 표현하기에도 적합하지 않다. 

## item63 문자열 연결은 느리니 주의하자
문자열 연결을 할때엔 + 기호를 이용해 편리하게 연결할 수 있다. 하지만 문자열은 불변이기 때문에 + 기호를 이용해 연결하면 두 문자열을 모두 복사한 뒤 새로운 문자열을 만들기 때문에 성능의 이슈가 생긴다. 성능을 생각한다면 문자열 연결은 StringBuilder를 사용하자

## item64 객체는 인터페이스를 사용해 참조하라
아이템51 에서 객체는 클래스가 아닌 인터페이스로 참조하라고 책에서 조언했다. 이걸 확장해 객체는 클래스가 아닌 인터페이스로 참조하라고 확장할 수 있다. 매개변수 뿐만아니라 반환값, 변수, 필드 모두 인터페이스타입으로 선언하라. 인터페이스를 타입으로 사용하는 습관을 기르면 프로그램이 훨씬 유연해질 것이다. 

```java
Set<String> stringSet = new LinkedHashSet<>();
```

```java
Set<String> stringSet = new HashSet<>();
```

stringSet의 타입이 LinkedHashSet에서 HashSet으로 바꼈지만 생성하는 코드만 바꼈을뿐 다른 코드들은 바뀌지 않았을 것이다. 